#!/bin/bash

# to restore the terminal state and exit with a code
quit() {
	popd > /dev/null 2>&1 # restore user's working directory quietly
	stty echo             # unhide their keystrokes
	exit $1               # exit with a given code
}

# to print a message, with its type highlighted
# in a color
msg() {
	# for compatibility across terminals, use
	# tput instead of awkward ANSI escape codes
	tput bold

	if [[ $1 = "ERROR" ]]; then
		tput setaf 1 # red for error messages
	elif [[ $1 = "WARNING" ]]; then
		tput setaf 3 # yellow for warning ones
	else
		tput setaf 7 # and white for anything else
	fi

	echo -n $1
	tput setaf 7
	echo -n ": "
	tput sgr0
	echo -e $2
}

# to display an error and also quit with non-zero
error() { 
	msg "ERROR" "$1" # then, actually print the error
	quit 1 # exit with error code
}

# to check if a package exists
exist_check() {
	[[ -z $1 ]] && error "package name not provided!"

	# checking return type to see if the package exists
	grep -w $1 $FPKG_ROOT/pkg.lst > /dev/null ||
		error "$1 not found in pkg.lst! \
		\nWas it a typo?"
}

# to check if elevated privileges are needed
write_check() {
	# get return code to see if we can write to any of the files
	touch $FPKG_ROOT > /dev/null
	RET=$(( RET + $? ))
	touch $FPKG_ROOT/pkg.lst > /dev/null
	RET=$(( RET + $? ))
	touch $FPKG_ROOT/ii > /dev/null
	RET=$(( RET + $? ))

	# if any of the touch's fail
	[[ $RET > 0 ]] &&
		error "$FPKG_ROOT is unwriteable! \
		\nTry running as root instead."
}

# to perform an update
update() {
	# check what kind of VCS we have
	if [[ -d ".git/" ]]; then
		PULL_WITH=(--recurse-submodules=on-demand)

		# check if rebase is required
		[[ $REBASE = "YES" ]] && PULL_WITH+=(--rebase)

		git pull ${PULL_WITH[@]}
	else
		# don't print that "Updating"
		# line, make it a lil' cleaner
		svn update | tail -n+2
	fi

	# and then go to the previous dir
	cd - > /dev/null
}

# check if user has at least one of
# the following VCSes: git
which git > /dev/null 2>&1 && HAS_GIT=true
# and svn
which svn > /dev/null 2>&1 && HAS_SVN=true

[[ ! $HAS_GIT ]] && [[ ! $HAS_SVN ]] &&
	error "no compatible VCSes found! \
	\nTry installing at least one of: git, svn."


# get our configuration file containing all the
# environment variables needed for this to work
source /etc/fpkg.conf || exit 2

# then, check if we even have a proper setup
if [[ -z $FPKG_ROOT ]] || [[ -z $EDITOR ]]; then
	msg "ERROR" "\$FPKG_ROOT and/or \$EDITOR unset! \
		\nSet both of these variables and try again."

	quit 2
else
	# then go set the environment up
	stty -echo          # hide keystrokes, not sure how to discard them too
	pushd . > /dev/null # save user's current directory
	cd $FPKG_ROOT       # so that we can go to $FPKG_ROOT
fi

# check if $FPKG_ROOT exists in the first place,
# else perform an initial setup
if [[ ! -d $FPKG_ROOT ]]; then
	msg "ERROR" "$FPKG_ROOT does not exist! Create it now? [Y/n] "
	read CHOICE

	if [[ $CHOICE != "n" ]]; then # so that the default is "yes"
		mkdir -pv $FPKG_ROOT/ii   # create the ii one too already
		cp .bashrc $FPKG_ROOT     # and copy .bashrc to the main dir 
	fi

	quit 1
fi

# also check if ii/ exists too,
# in case only the former already existed
if [[ ! -d $FPKG_ROOT/ii ]]; then
	msg "ERROR" "$FPKG_ROOT/ii does not exist! \
		\nCreating it and aborting now..."
	mkdir -pv $FPKG_ROOT/ii

	quit 1
fi

# now, parse the command line arguments!
case $1 in
	# refresh all packages using their
	# source VCS' tool
	"update" | "u")
		# no extra arguments? then all packages will be checked
		if [[ -z $2 ]] || [[ $2 = "-x" ]]; then
			# get what packages we have
			ENTRIES=("$(awk '{ print $1 }' pkg.lst | tr '\n' ' ')")

			# check if we've got packages to exclude from
			# our upgrade session
			if [[ $2 = "-x" ]]; then
				for EXCLUDE in ${@:3}; do
					exist_check $EXCLUDE
					ENTRIES=("$(echo ${ENTRIES[@]} | sed "s/$EXCLUDE//")")
				done
			fi

			for PKG in ${ENTRIES[@]}; do
				cd $PKG > /dev/null

				if [[ $? != 0 ]]; then
					# couldn't change to that package's directory?
					msg "WARNING" \
						"$PKG does not exist! \
						\nRemove its entry with \`fpkg delete' and retry."
					continue
				fi

				msg "$PKG" ""
				update
			done
		# or update just that particular package
		else
			for ITEM in ${@:2}; do
				exist_check $ITEM
				cd $ITEM

				# weird way of checking if a package needs rebase or not
				[[ -d ".git/" ]] &&
					export \
						$(grep "$ITEM REBASE" $FPKG_ROOT/pkg.lst | \
							awk '{ print $2 }')
				# check if we've got more than a single
				# package to update
				[[ $# > 2 ]] && msg "$ITEM" ""
				# and perform it
				update
			done
		fi
		;;

	# requested the installation of a package?
	"install" | "i")
		# check if we got more than one item
		# to install as well
		for ITEM in ${@:2}; do
			exist_check $ITEM
			write_check

			cd $FPKG_ROOT/$ITEM

			# change window title too so that the user
			# knows it's still running
			echo -en '\e]0;fpkg: building...\a'

			# check if the installation requires
			# interaction with the user
			export $(grep INTERACTIVE $FPKG_ROOT/ii/$ITEM.ii)

			# if it does, unhide keystrokes here 
			[[ $INTERACTIVE = "YES" ]] && stty echo

			# get the installation instructions from
			# the package's ii
			source $FPKG_ROOT/ii/$ITEM.ii

			if [[ $FPKG_LOG && $LOG_FMT ]]; then
				# check if the log dir exists first
				# and create it accordingly as it's 
				# by default inside /tmp
				[[ ! -d $FPKG_LOG ]] && mkdir $FPKG_LOG

				# $LOG_FMT gets expanded here for creating the file
				LOGFILE=$FPKG_LOG/$(printf "$ITEM-%($LOG_FMT)T")

				install | tee -a $LOGFILE
			else
				install
			fi
		done

		# and then, ring the terminal bell when done, and that
		# if the operation has succeeded
		[[ $? = 0 ]] && tput bel

		# then, tell the user about the log file
		# location
		[[ $FPKG_LOG && $LOG_FMT ]] &&
			echo -e \\n"Build log(s) saved to $LOGFILE."
		;;

	# requested the uninstallation of a package?
	"remove" | "r")
		exist_check $2
		write_check

		cd $2

		# ditto, but for uninstalling it
		source $FPKG_ROOT/ii/$2.ii; remove

		# ask if the user wants to completely remove it
		# from their system as well
		if [[ $? = 0 ]]; then
			stty echo
			echo    "Would you like to remove this package's"
			echo    "entry from pkg.lst and its files as"
			echo -n "well? [y/N] "
			read CHOICE

			if [[ $CHOICE = 'y' ]]; then # default to 'no' just to be safe
				# get index number of package
				ENTRY=$(grep -wn "^$2" pkg.lst | awk -F":" '{ print $1 }')
				sed -i "$ENTRY"d pkg.lst # and delete the package from it
				rm ii/$2.ii
				rm -rf $2 || error "failed to delete $2!"
			fi

			echo "Done!"
		fi
		;;

	# requested the list of registered packages?
	"list" | "l")
		awk '{ print $1 }' pkg.lst

		# tell user how many packages in total
		# they have too
		echo
		msg "Total" "$(cat pkg.lst | wc -l)"
		;;

	# adding an entry to the list?
	"add" | "a")
		# check if we even have the package's name first
		[[ -z $2 ]] && error "package name not provided!"

		# then, check if we have the directory for the
		# requested package
		[[ ! -d $FPKG_ROOT/$2 ]] &&
			error "directory for package not found! \
			\nWas it a typo?"

		# check if version control type is supported by
		# this script too
		[[ ! -d $FPKG_ROOT/$2/.git ]] &&
		[[ ! -d $FPKG_ROOT/$2/.svn ]] &&
			error "incompatible VCS or none found! \
			\nSupported ones are: git, svn."

		grep -w $2 pkg.lst > /dev/null && error "$2 already registered!"

		write_check

		# make keystrokes visible again
		stty echo
		
		# add package to the list
		tput bold; tput setaf 6
		echo -n "Detected VCS: " # tell the user about it prettily
		tput sgr0
		if [[ -d $FPKG_ROOT/$2/.git ]]; then
			echo "Git"
			echo "Does your package require to be updated with"
			echo -n "\`git pull --rebase'? [y/N] "
			read CHOICE

			if [[ $CHOICE = 'y' ]]; then
				echo "$2 REBASE=YES" >> pkg.lst
			else
				echo "$2 REBASE=NO" >> pkg.lst
			fi
		else
			echo "Subversion"
			echo "$2" >> pkg.lst
		fi

		# write a template for it to make it easier for the user
		# i couldn't get this to work by using a single call to
		# echo so i came up with this
		echo    "# - Installation instructions for package $2 -"   >  ii/$2.ii
		echo    "# Inside install(), write the commands for"       >> ii/$2.ii
		echo    "# installing the package, and inside remove(),"   >> ii/$2.ii
		echo -e "# write the commands for uninstalling it too."\\n >> ii/$2.ii
		
		# write a commented out privilege check section so that if
		# there're any steps requiring elevated privileges a check
		# is made for it
		echo    "# Uncomment if elevated privileges are required"    >> ii/$2.ii
		echo    "# for installing this package"                      >> ii/$2.ii
		echo    "#if [[ \$(id -u) != 0 ]]; then"					 >> ii/$2.ii
		echo -e "#\\techo \"This action requires root privileges!\"" >> ii/$2.ii
		echo -e "#\\tstty echo" >> ii/$2.ii
		echo -e "#\\texit 1"                                         >> ii/$2.ii
		echo -e "#fi"\\n                                             >> ii/$2.ii

		echo    "# Say 'YES' if interaction is required"    >> ii/$2.ii
		echo    "# to install this package, otherwise keep" >> ii/$2.ii
		echo    "# this 'NO'. Don't remove this line!!"     >> ii/$2.ii
		echo -e "INTERACTIVE=NO"\\n                         >> ii/$2.ii

		echo -e "install() {"\\n\\n"}"\\n >> ii/$2.ii
		echo -e "remove() {"\\n\\n"}"\\n  >> ii/$2.ii

		# open up the text editor so that the user can write on
		# that template
		$EDITOR ii/$2.ii

		# make it safer and only let the owner write to it
		chmod 0644 ii/$2.ii

		# and we're done
		echo "Done."
		;;

	# just checking an .ii?
	"peek" | "p")
		exist_check $2

		less ii/$2.ii
		;;

	# going to the package's directory?
	"goto" | "g")
		exist_check $2

		# see if we even have the .bashrc to begin with
		[[ -r $FPKG_ROOT/.bashrc ]] ||
			error "no existing or readable .bashrc on \$FPKG_ROOT!"

		stty echo

		export FPKG_ROOT  # those are necessary to make it able to start the
		export PKG_DIR=$2 # shell at the desired directory

		# go to that directory
		# and tell the user about it
		sh -c 'cd $FPKG_ROOT/$PKG_DIR;
		       echo "Working on $PKG_DIR/, hit ^D to exit";
		       exec bash --rcfile $FPKG_ROOT/.bashrc' # and here it goes
		;;

	# editing a package's .ii?
	"edit" | "e")
		exist_check $2
		write_check

		stty echo

		$EDITOR ii/$2.ii
		;;

	# switching to another branch/revision?
	"switch" | "s")
		exist_check $2
		write_check

		cd $2

		if [[ ! -z $3 ]]; then
			if [[ -d ".git/" ]]; then
				git switch $3
			else
				svn switch $3
			fi
		else
			error "branch not provided!"
		fi
		;;

	# delete an entry from the list?
	"delete" | "d")
		exist_check $2
		write_check

		stty echo

		# get index number of package
		ENTRY=$(grep -wn "^$2" pkg.lst | awk -F":" '{ print $1 }')
		sed -i "$ENTRY"d pkg.lst # and delete the package from it
		rm ii/$2.ii
		echo "$2 removed from pkg.lst, would you like to remove its files"
		echo -n "as well? [y/N] "
		read CHOICE

		[[ $CHOICE = 'y' ]] && rm -vrf $2

		echo "Done!"
		;;

	# requested the message of last git commit?
	"message" | "m")
		[[ $2 = "-d" ]] && shift

		for ITEM in ${@:2}; do
			exist_check $ITEM
			cd $ITEM

			if [[ -d ".git/" ]]; then
				# and its diff?
				if [[ $1 = "-d" ]]; then
					git show
				else
					[[ $# > 2 ]] && msg "$ITEM" ""
					# our message format for git
					PRETTY=("%C(white default bold)Who:%C(reset) %cn"
						"%n%C(white default bold)What:%C(reset) %s")

					# check if we got a commit body to print as well
					[[ ! -z $(git --no-pager log -1 --pretty="%b") ]] &&
						PRETTY+=("%n%C(white default bold)Details:%C(reset) %b")

					git --no-pager log -1 --pretty="${PRETTY[*]}"
					# also print a blank line unless it's the last
					# message on the list
					[[ $# > 2 ]] && [[ $ITEM != ${@:$#} ]] && echo
				fi
			else
				# add a pager to the diff output like
				# in git's as well
				if [[ $1 = "-d" ]]; then
					svn log -l1 -v --diff | less
				else
					# remove those hyphens at the top and
					# bottom of the output to make it
					# cleaner
					svn log -l1 -v | head -n-1 | tail -n+2
				fi
			fi
			[[ $# > 2 ]] && cd - > /dev/null
		done
		;;

	# requested the commit history?
	"history" | "H")
		# check if argument is a number,
		# and define our depth to that
		if [[ $2 =~ ^[0-9]+$ ]]; then
			DEPTH=$2
			shift
		else
			DEPTH=5
		fi

		exist_check $2
		cd $2

		if [[ -r ".git/" ]]; then
			PRETTY=("%C(white default bold)(%cd)"
				"%nWho:%C(reset) %cn"
				"%n%C(white default bold)What:%C(reset) %s"
				"%n%b")
			git --no-pager log -$DEPTH --pretty="${PRETTY[*]}"
		else
			svn log -l$DEPTH -v | head -n-1 | tail -n+2
		fi
		;;

	# requested the version?
	"version" | "v")
		tput bold
		echo "fpkg v4.0.0a"
		tput sgr0
		echo "written by ruby (https://github.com/ruby-R53),"
		echo "on August 2025."
		;;

	# didn't even input a valid action or wants to know
	# them?
	"help" | "h" | *)
		msg "Usage" "$0 <action>"
		msg "Actions (and their short forms)" ""
		echo "(u)pdate [-x] [pkg(s)] - update every package listed in pkg.lst, you"
		echo "                         may also choose to update one or some of"
		echo "                         them, or e[x]clude from the list"
		echo "(i)nstall <pkg>        - install <pkg> using \$FPKG_ROOT/ii/<pkg>.ii"
		echo "(r)emove <pkg>         - or uninstall it using the same file"
		echo "(l)ist                 - list registered packages"
		echo "(a)dd <pkg>            - register <pkg>"
		echo "(p)eek <pkg>           - peek into <pkg>'s .ii"
		echo "(g)oto <pkg>           - start a shell session at <pkg>'s directory"
		echo "(e)dit <pkg>           - edit <pkg>'s .ii"
		echo "(d)elete <pkg>         - unregister <pkg>, you may also delete its files"
		echo "                         as well"
		echo "(m)essage [-d] <pkg>   - get commit message from <pkg>. Takes an optional"
		echo "                         -d switch to get its diff as well, and you may"
		echo "                         specify multiple packages"
		echo "(H)istory [n] <pkg>    - get <pkg>'s commit history. Takes an optional"
		echo "                         number [n] for a custom depth. Defaults to 5"
		echo "(s)witch <pkg> <brnch> - switch <pkg>'s branch to <brnch>"
		echo "(h)elp                 - show this help message"
		echo "(v)ersion              - get fpkg's version"

		# exit with error code if input wasn't
		# for the help text
		[[ $1 != "help" ]] && [[ $1 != "h" ]] && quit 1
		;;
esac

# and the program is done!
quit 0
