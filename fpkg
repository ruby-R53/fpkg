#!/bin/bash

# to restore the terminal state and exit with a code
quit() {
	popd > /dev/null 2>&1 # restore user's working directory quietly
	stty echo             # unhide their keystrokes
	exit $1               # exit with a given code
}

# to print a message, with its type highlighted
# in a color
msg() {
	# for compatibility across terminals, use
	# tput instead of awkward ANSI escape codes
	tput bold

	if [[ $1 = "ERROR" ]]; then
		tput setaf 1 # red for error messages
	elif [[ $1 = "WARNING" ]]; then
		tput setaf 3 # yellow for warning ones
	else
		tput setaf 7 # and white for anything else
	fi

	printf "$1"
	tput setaf 7
	printf ": "
	tput sgr0
	printf "${*:2}"
}

# to display an error and also quit with non-zero
error() { 
	msg "ERROR" "${*:1}\n"
	quit 1 # FIXME should this not be hardcoded?
}

# to check if a package exists
exist_check() {
	[[ -z $1 ]] && error "package name not provided!"

	# checking return type to see if the package exists
	grep -E "^$1( )" $FPKG_ROOT/pkg.lst > /dev/null ||
		error "$1 not found in pkg.lst!" "\nWas it a typo?"
}

# to check if elevated privileges are needed
write_check() {
	# get return code to see if we can write to any of the files
	touch $FPKG_ROOT > /dev/null
	RET=$(( RET + $? ))
	touch $FPKG_ROOT/pkg.lst > /dev/null
	RET=$(( RET + $? ))
	touch $FPKG_ROOT/ii > /dev/null
	RET=$(( RET + $? ))

	# if any of the touch's fail
	[[ $RET > 0 ]] &&
		error \
			"$FPKG_ROOT is unwriteable!"\
			"\nTry running as root instead."
}

# to get the index number of a package, used for
# operations with sed (for now)
get_idx() {
	export INDEX=$(grep -wno "^$1" pkg.lst | cut -d':' -f1)
}

# check if the user has VCS modules
[[ -z "$(ls /etc/fpkg/modules/)" ]] &&
	error "no VCS modules found!" "\nAborting..."

# get our configuration file containing all the
# environment variables needed for this to work
source /etc/fpkg.conf || error "failed to get configuration file! Aborting..."

# then, check if we even have a proper setup
if [[ -z $FPKG_ROOT ]] || [[ -z $EDITOR ]]; then
	msg "ERROR"\
		"\$FPKG_ROOT and/or \$EDITOR unset!"\
		"\nSet both of these variables and try again."

	quit 2
else # then go set the environment up
	stty -echo          # hide keystrokes, not sure how to discard them too
	pushd . > /dev/null # save user's current directory
	cd $FPKG_ROOT       # so that we can go to $FPKG_ROOT
fi

# check if $FPKG_ROOT exists in the first place,
# else perform an initial setup
if [[ ! -d $FPKG_ROOT ]]; then
	msg "ERROR"\
		"$FPKG_ROOT does not exist! Create it now? [Y/n] "
	read CHOICE

	if [[ $CHOICE != "n" ]]; then # so that the default is "yes"
		mkdir -pv $FPKG_ROOT/ii   # create the ii one too already
		cp .bashrc $FPKG_ROOT     # and copy .bashrc to the main dir 
	fi

	quit 1
fi

# also check if ii/ exists too,
# in case only the former already existed
if [[ ! -d $FPKG_ROOT/ii ]]; then
	msg "ERROR"\
		"$FPKG_ROOT/ii does not exist!"\
		"\nCreating it and aborting now..."
	mkdir -pv $FPKG_ROOT/ii

	quit 1
fi

# now, parse the command line arguments!
case $1 in
	# refresh all packages using their
	# source VCS' tool
	"update" | "u")
		# get what packages we have
		ENTRIES=("$(cut -d' ' -f1 pkg.lst | tr '\n' ' ')")

		if [[ ! -z $2 ]]; then
			if [[ $2 = "-x" ]]; then
				for EXCLUDE in ${@:3}; do
					exist_check $EXCLUDE
					ENTRIES=("$(echo ${ENTRIES[@]} | sed "s/$EXCLUDE//")")
				done
			else
				ENTRIES="${@:2}"
			fi
		fi

		for ENTRY in ${ENTRIES[@]}; do
			exist_check $ENTRY
			# check if we own the directory before performing the update
			# on it
			CURR_USRGRP=($(id -nu | tr '\n' ' '; id -nG))
			OWNER_USRGRP=($(stat -c "%U %G" .))
			if [[ ${CURR_USRGRP[0]} == ${OWNER_USRGRP[0]} ]]; then
				for GROUP in ${CURR_USRGRP[@]:1}; do
					# keep trying until we get a match
					[[ $GROUP == ${OWNER_USRGRP[1]} ]] && break
				done
				[[ $GROUP != ${OWNER_USRGRP[1]} ]] &&
					error "your group doesn't own this package's directory!"
			else
				error "your user doesn't own this package's directory!"
			fi

			export $(grep "$ENTRY" $FPKG_ROOT/pkg.lst | grep -o "VCS_MDL=.*")
			source /etc/fpkg/modules/$VCS_MDL.fmd
			cd $ENTRY

			# weird way of checking if a package needs rebase or not
			# or if a shallow update was requested for it
			[[ -d ".git/" ]] &&
				export $(grep "$ENTRY" $FPKG_ROOT/pkg.lst | cut -d' ' -f2-)

			# check if we only have one selected package
			# to update, otherwise print message to indicate
			# which one is being updated
			[[ $# = 1 ]] || [[ $# > 2 ]] && msg "$ENTRY" "\n"
			update

			# and then go to the previous dir
			cd - > /dev/null
		done
		;;

	# requested the installation of a package?
	"install" | "i")
		# check if we got more than one item
		# to install as well
		for PKG in ${@:2}; do
			exist_check $PKG
			write_check

			cd $FPKG_ROOT/$PKG

			# change window title too so that the user
			# knows it's still running
			printf "\e]0;fpkg: building...\a"

			# check if the installation requires
			# interaction with the user
			export $(grep INTERACTIVE $FPKG_ROOT/ii/$PKG.ii)

			# if it does, unhide keystrokes here 
			[[ $INTERACTIVE = "YES" ]] && stty echo

			# get the installation instructions from
			# the package's ii
			source $FPKG_ROOT/ii/$PKG.ii

			if [[ $FPKG_LOG && $LOG_FMT ]]; then
				# check if the log dir exists first
				# and create it accordingly as it's 
				# by default inside /tmp
				[[ ! -d $FPKG_LOG ]] && mkdir $FPKG_LOG

				# $LOG_FMT gets expanded here for creating the file
				LOGFILE=$FPKG_LOG/$(printf "$PKG-%($LOG_FMT)T")

				install | tee -a $LOGFILE
			else
				install
			fi
		done

		# and then, ring the terminal bell when done, and that
		# if the operation has succeeded
		[[ $? = 0 ]] && tput bel

		# then, tell the user about the log file
		# location
		[[ $FPKG_LOG && $LOG_FMT ]] &&
			printf "\nBuild log(s) saved to $LOGFILE."
		;;

	# requested the uninstallation of a package?
	"remove" | "r")
		exist_check $2
		write_check

		cd $2

		# ditto, but for uninstalling it
		source $FPKG_ROOT/ii/$2.ii; remove

		# ask if the user wants to completely remove it
		# from their system as well
		if [[ $? = 0 ]]; then
			stty echo
			printf \
				"Would you like to remove this package's\n"\
				"entry from pkg.lst and its files as\n"\
				"well? [y/N] "
			read CHOICE

			if [[ $CHOICE = 'y' ]]; then # default to 'no' just to be safe
				get_idx $2
				sed -i "${INDEX}d" pkg.lst # and delete the package from it
				rm ii/$2.ii
				rm -rf $2 || error "failed to delete $2!"
			fi

			echo "Done!"
		fi
		;;

	# requested the list of registered packages?
	"list" | "l")
		cut -d' ' -f1 pkg.lst

		# tell user how many packages in total
		# they have too
		echo
		msg "Total" "$(cat pkg.lst | wc -l)\n"
		;;

	# adding an entry to the list?
	"add" | "a")
		# check if we even have the package's name first
		[[ -z $2 ]] && error "package name not provided!"

		# then, check if we have the directory for the
		# requested package
		[[ ! -d $FPKG_ROOT/$2 ]] &&
			error \
				"directory for package not found!"\
				"\nWas it a typo?"

		grep -w $2 pkg.lst > /dev/null && error "$2 already registered!"

		write_check

		# check if version control type is supported by
		# this script too
		tput bold; tput setaf 6
		printf "Detecting VCS... " # tell the user about it prettily
		tput sgr0
		# try one of them until they match the 
		# package's contents
		for VCS_MDL in $FPKG_ROOT/modules/*; do
			source $VCS_MDL
			# add package to the list
			export PKG=$2
			register || continue
		done
		# if all VCS modules don't support it...
		[[ $UNSUPPORTED = "$(ls $FPKG_ROOT/modules/* | wc -l)" ]] &&
			error "no compatible VCS for package found!"

		# then, write a template for it to make it easier for the user
		printf \
			"# - Installation instructions for package $2 -\n"\
			"# Inside install(), write the commands for\n"\
			"# installing the package, and inside remove(),\n"\
			"# write the commands for uninstalling it too.\n" > ii/$2.ii
		
		# also write a commented out privilege check section so that if
		# there're any steps requiring elevated privileges a check
		# is done for that
		printf "\n"\
			"# Uncomment if elevated privileges are required\n"\
			"# for installing this package\n"\
			"#if [[ \$(id -u) != 0 ]]; then\n"\
			"#\techo \"This action requires root privileges!\"\n"\
			"#\tstty echo\n"\
			"#\texit 1\n"\
			"#fi\n" >> ii/$2.ii

		printf "\n"\
			"# Say 'YES' if interaction is required\n"\
			"# to install this package, otherwise keep\n"\
			"# this 'NO'. Don't remove this line!!\n"\
			"INTERACTIVE=NO\n" >> ii/$2.ii

		# then, the actual installation process
		printf "\n"\
			"install() {\n\n}\n\n"\
			"remove() {\n\n}" >> ii/$2.ii

		# open up the text editor so that the user can write on
		# that template
		$EDITOR ii/$2.ii

		# make it safer and only let the owner write to it
		chmod 0644 ii/$2.ii

		# and we're done
		echo "Done."
		;;

	# just checking an .ii?
	"peek" | "p")
		exist_check $2

		less ii/$2.ii
		;;

	# going to the package's directory?
	"goto" | "g")
		exist_check $2

		[[ -r "/etc/fpkg/bashrc" ]] ||
			error "no existing or readable bashrc file found in /etc/fpkg/!"

		stty echo

		export FPKG_ROOT  # those are necessary to make it able to start the
		export PKG_DIR=$2 # shell at the desired directory

		# go to that directory
		# and tell the user about it
		sh -c 'cd $FPKG_ROOT/$PKG_DIR;
		       echo "Working on $PKG_DIR/, hit ^D to exit";
		       exec bash --rcfile /etc/fpkg/bashrc' # and here it goes
		;;

	# editing a package's .ii?
	"edit" | "e")
		exist_check $2
		write_check

		stty echo

		$EDITOR ii/$2.ii
		;;

	# switching to another branch/revision?
	"switch" | "s")
		exist_check $2
		write_check

		if [[ ! -z $3 ]]; then
			cd $2

			export $(grep "$2" $FPKG_ROOT/pkg.lst | grep -o "VCS_MDL=.*")
			source /etc/fpkg/modules/$VCS_MDL.fmd
			BRANCH=$3
			swbrnch
		else
			error "branch not provided!"
		fi
		;;

	# delete an entry from the list?
	"delete" | "d")
		exist_check $2
		write_check

		stty echo

		get_idx $2
		sed -i "${INDEX}d" pkg.lst # and delete the package from it
		rm ii/$2.ii
		printf \
			"$2 removed from pkg.lst, would you like to remove its files\n"\
			"as well? [y/N] "
		read CHOICE

		[[ $CHOICE = 'y' ]] && rm -vrf $2

		echo "Done!"
		;;

	# requested the message of last git commit?
	"message" | "m")
		if [[ $2 = "-d" ]]; then
			DIFF=true
			shift
		fi

		for PKG in ${@:2}; do
			exist_check $PKG
			cd $PKG

			export $(grep "$PKG" $FPKG_ROOT/pkg.lst | grep -o "VCS_MDL=.*")
			source /etc/fpkg/modules/$VCS_MDL.fmd

			# print each package's name if we've got 2 or more
			[[ $# > 2 ]] && msg "$PKG"

			# then, actually get its commit message
			getmsg

			# go back to the previous directory if we've got
			# more than one package
			[[ $# > 2 ]] && cd - > /dev/null

			# also print a blank line unless it's the last
			# message on the list
			[[ $# > 2 ]] && [[ $PKG != ${@:$#} ]] && echo
		done
		;;

	# requested the commit history?
	"history" | "H")
		# check if argument is a number,
		# and define our depth to that
		if [[ $2 =~ ^[0-9]+$ ]]; then
			DEPTH=$2
			shift
		else
			DEPTH=5
		fi

		exist_check $2
		cd $2

		export $(grep "$PKG" $FPKG_ROOT/pkg.lst | grep -o "VCS_MDL=.*")
		source /etc/fpkg/modules/$VCS_MDL.fmd

		gethst
		;;

	# requested the version?
	"version" | "v")
		tput bold
		echo "fpkg v4.0.0a"
		tput sgr0
		echo "written by ruby (https://github.com/ruby-R53),"
		echo "during August to October 2025."
		;;

	# didn't even input a valid action or wants to know
	# them?
	"help" | "h" | *)
		msg "Usage" "$0 <action>"
		msg "\nActions (and their short forms)" \
			"\n(u)pdate [-x] [pkg(s)] - update every package listed in pkg.lst, you" \
			"\n                         may also choose to update one or some of" \
			"\n                         them, or e[x]clude from the list" \
			"\n(i)nstall <pkg>        - install <pkg> using \$FPKG_ROOT/ii/<pkg>.ii" \
			"\n(r)emove <pkg>         - or uninstall it using the same file" \
			"\n(l)ist                 - list registered packages" \
			"\n(a)dd <pkg>            - register <pkg>" \
			"\n(p)eek <pkg>           - peek into <pkg>'s .ii" \
			"\n(g)oto <pkg>           - start a shell session at <pkg>'s directory" \
			"\n(e)dit <pkg>           - edit <pkg>'s .ii" \
			"\n(d)elete <pkg>         - unregister <pkg>, you may also delete its files" \
			"\n                         as well" \
			"\n(m)essage [-d] <pkg>   - get commit message from <pkg>. Takes an optional" \
			"\n                         -d switch to get its diff as well, and you may" \
			"\n                         specify multiple packages" \
			"\n(H)istory [n] <pkg>    - get <pkg>'s commit history. Takes an optional" \
			"\n                         number [n] for a custom depth. Defaults to 5" \
			"\n(s)witch <pkg> <brnch> - switch <pkg>'s branch to <brnch>" \
			"\n(h)elp                 - show this help message" \
			"\n(v)ersion              - get fpkg's version\n"

		# exit with error code if input wasn't
		# for the help text
		[[ $1 != "help" ]] && [[ $1 != "h" ]] && quit 1
		;;
esac

# and the program is done!
quit 0
